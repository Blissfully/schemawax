"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.recursive=exports.object=exports.keyValuePairs=exports.record=exports.tuple=exports.iterable=exports.array=exports.regex=exports.literalUnion=exports.oneOf=exports.literal=exports.boolean=exports.number=exports.string=exports.unknown=exports.nullable=exports.checkDefined=exports.DecoderError=exports.createDecoder=void 0;const createDecoder=decoder=>Object.assign(Object.assign({},decoder),{decode:data=>{try{return decoder.forceDecode(data)}catch(_a){return null}},validate:data=>{try{return{type:"ok",data:decoder.forceDecode(data)}}catch(e){if(e instanceof DecoderError){return{type:"error",error:e}}throw e}},is:data=>{try{decoder.forceDecode(data);return true}catch(_a){return false}},andThen:transformer=>{return exports.createDecoder({forceDecode:data=>transformer(decoder.forceDecode(data))})}});exports.createDecoder=createDecoder;class DecoderError extends SyntaxError{constructor(message,path=[]){super(message);this.name="DecoderError";this.path=path;Object.setPrototypeOf(this,new.target.prototype);if(this.path.length===1){this.message=`${this.path[0]}: ${this.message}`}else if(this.path.length>1){this.message=`${this.path[0]}.${this.message}`}}}exports.DecoderError=DecoderError;const forceDecodeWithPath=(decoder,data,pathPart)=>{try{return decoder.forceDecode(data)}catch(e){if(e instanceof DecoderError){throw new DecoderError(e.message,[pathPart,...e.path])}else{throw e}}};const show=data=>JSON.stringify(data,null,2);const checkDefined=data=>{if(data==null)throw new DecoderError("This value is not there");return false};exports.checkDefined=checkDefined;const nullable=decoder=>exports.createDecoder({forceDecode:data=>data===null?null:decoder.forceDecode(data)});exports.nullable=nullable;const primitiveDecoder=(dataType,condition)=>exports.createDecoder({forceDecode:data=>{exports.checkDefined(data);if(!condition(data)){throw new DecoderError(`This is not ${dataType}: ${show(data)}`)}return data}});exports.unknown=exports.createDecoder({forceDecode:data=>data});exports.string=primitiveDecoder("a string",$=>typeof $==="string");exports.number=primitiveDecoder("a number",$=>typeof $==="number"&&Number.isFinite($));exports.boolean=primitiveDecoder("a boolean",$=>typeof $==="boolean");const literal=literal=>exports.createDecoder({forceDecode:data=>{exports.checkDefined(data);if(data!==literal){throw new DecoderError(`Data does not match the literal. Expected: '${literal}', actual value: '${show(data)}'`)}return data}});exports.literal=literal;const oneOf=(...decoders)=>exports.createDecoder({forceDecode:data=>{var _a;const errors=[];for(const decoder of decoders){try{return decoder.forceDecode(data)}catch(e){errors.push((_a=e.message)!==null&&_a!==void 0?_a:"Unknown error")}}throw new DecoderError(`None of the decoders worked:\n${show(errors)}`)}});exports.oneOf=oneOf;const literalUnion=(...decoders)=>exports.oneOf(...decoders.map(exports.literal));exports.literalUnion=literalUnion;const regex=regex=>exports.string.andThen(data=>{if(!regex.test(data))throw new DecoderError(`Data '${data}' does not satisfy the regex '${regex.toString()}'`);return data});exports.regex=regex;function checkArrayType(data){if(!Array.isArray(data))throw new DecoderError(`This is not an array: ${show(data)}`)}const array=decoder=>exports.createDecoder({forceDecode:data=>{exports.checkDefined(data);checkArrayType(data);return data.map((x,i)=>forceDecodeWithPath(decoder,x,i.toString()))}});exports.array=array;function readIterable(data){if(typeof data!=="object"||data===null){throw new DecoderError(`This is not an object: ${show(data)}`)}else if(!(Symbol.iterator in data)){throw new DecoderError(`This object is not iterable: ${show(data)}`)}else{try{return[...data]}catch(_a){throw new DecoderError(`This object has an invalid iterator: ${show(data)}`)}}}const iterable=decoder=>exports.createDecoder({forceDecode:data=>{exports.checkDefined(data);return readIterable(data).map((x,i)=>forceDecodeWithPath(decoder,x,i.toString()))}});exports.iterable=iterable;const tuple=(...decoders)=>exports.createDecoder({forceDecode:data=>{exports.checkDefined(data);checkArrayType(data);if(decoders.length>data.length){throw new DecoderError(`The tuple is not long enough. ${decoders.length} > ${data.length}`)}return decoders.map((decoder,index)=>forceDecodeWithPath(decoder,data[index],index.toString()))}});exports.tuple=tuple;function checkDictType(data){if(typeof data!=="object"||data===null||Array.isArray(data)){throw new DecoderError(`This is not an object: ${show(data)}`)}else if(Object.keys(data).some($=>typeof $!=="string")){throw new DecoderError(`Not all keys in this object are strings: ${show(data)}`)}}const record=decoder=>exports.createDecoder({forceDecode:data=>{exports.checkDefined(data);checkDictType(data);return Object.fromEntries(Object.entries(data).map(([key,value])=>[key,forceDecodeWithPath(decoder,value,key)]))}});exports.record=record;const keyValuePairs=decoder=>exports.createDecoder({forceDecode:data=>Object.entries(exports.record(decoder).forceDecode(data))});exports.keyValuePairs=keyValuePairs;const required=struct=>exports.createDecoder({forceDecode:data=>{checkDictType(data);const parsed={};for(const key in struct){if(data[key]===undefined)throw new DecoderError(`Object missing required property '${key}'`);parsed[key]=forceDecodeWithPath(struct[key],data[key],key)}return parsed}});const partial=struct=>exports.createDecoder({forceDecode:data=>{checkDictType(data);const parsed={};for(const key in struct){if(data[key]!==undefined){parsed[key]=forceDecodeWithPath(struct[key],data[key],key)}}return parsed}});const object=struct=>exports.createDecoder({forceDecode:data=>{exports.checkDefined(data);const result={};if(struct.required!==undefined){Object.assign(result,required(struct.required).forceDecode(data))}if(struct.optional!==undefined){Object.assign(result,partial(struct.optional).forceDecode(data))}return result}});exports.object=object;const recursive=decoder=>exports.createDecoder({forceDecode:data=>{return decoder().forceDecode(data)}});exports.recursive=recursive;